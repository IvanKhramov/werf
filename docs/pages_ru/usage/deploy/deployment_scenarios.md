---
title: Сценарии развертывания
permalink: usage/deploy/deployment_scenarios.html
---

## Обычное развертывание

Обычно развертывание осуществляется командой `werf converge`, которая собирает образы и развертывает приложение, но требует запуска из Git-репозитория приложения. Пример:

```shell
werf converge --repo example.org/mycompany/myapp
```

Если требуется разделить шаги сборки и развертывания, то это можно сделать так:

```shell
werf build --repo example.org/mycompany/myapp
```

```shell
werf converge --skip-build --repo example.org/mycompany/myapp
```

## Развертывание с использованием произвольных тегов образов

По умолчанию собранные образы получают тег на основе их содержимого, который становится доступен в Values для их дальнейшего использования в шаблонах при развертывании. Но если возникает необходимость тегировать образы иным тегом, то можно использовать параметр `--use-custom-tag`, например:

```shell
werf converge --use-custom-tag '%image%-v1.0.0' --repo example.org/mycompany/myapp
```

Результат: образы были собраны и опубликованы с тегами `<имя image>-v1.0.0`, после чего теги этих образов стали доступны в Values, на основе которых были сформированы и применены конечные манифесты Kubernetes.

В имени тега, указываемом в параметре `--use-custom-tag`, можно использовать шаблоны `%image%`, `%image_slug%` и `%image_safe_slug%` для подставления имени образа и `%image_content_based_tag%` для подставления оригинального тега на основе содержимого.

> Обратите внимание, что при указании произвольного тега публикуется также и образ с тегом на основе содержимого. В дальнейшем при вызове `werf cleanup` образ с тегом на основе содержимого и образы с произвольными тегами удаляются вместе.

Если требуется разделить шаги сборки и развертывания, то это можно сделать так:

```shell
werf build --add-custom-tag '%image%-v1.0.0' --repo example.org/mycompany/myapp
```

```shell
werf converge --skip-build --use-custom-tag '%image%-v1.0.0' --repo example.org/mycompany/myapp
```

## Развертывание без доступа к Git-репозиторию приложения

Если нужно развернуть приложение без доступа к Git-репозиторию приложения, то необходимо выполнить три шага:

1. Сборка образов и их публикация в container registry.

2. Публикация основного чарта и переданных ему параметров как *бандла* в OCI-репозиторий. Бандл содержит указатели на опубликованные в первом шаге образы.

3. Применение опубликованного бандла в кластер.

Первые два шага выполняются командой `werf bundle publish`, находясь в Git-репозитории приложения, например:

```shell
werf bundle publish --tag latest --repo example.org/mycompany/myapp
```

А третий шаг выполняется командой `werf bundle apply` уже без необходимости находиться в Git-репозитории приложения, например:

```shell
werf bundle apply --tag latest --release myapp --namespace myapp-production --repo example.org/mycompany/myapp
```

Конечный результат будет тот же самый, что и при использовании `werf converge`.

Если требуется разделить первый и второй шаг, то это можно сделать так:

```shell
werf build --repo example.org/mycompany/myapp
```

```
werf bundle publish --skip-build --tag latest --repo example.org/mycompany/myapp
```

## Развертывание сторонним инструментом

Если нужно выполнить применение конечных манифестов приложения не с werf, а с использованием другого инструмента (kubectl, Helm, ...), то необходимо выполнить три шага:

1. Сборка образов и их публикация в container registry.

2. Формирование конечных манифестов.

3. Развертывание получившихся манифестов в кластер используя сторонний инструмент.

Первые два шага выполняются командой `werf render`, находясь в Git-репозитории приложения:

```shell
werf render --output manifests.yaml --repo example.org/mycompany/myapp
```

Теперь полученные манифесты можно передать в сторонний инструмент для дальнейшего развертывания, например:

```shell
kubectl apply -f manifests.yaml
```

> Обратите внимание, что некоторые специальные возможности werf вроде возможности изменения порядка развертывания ресурсов на основании их веса (аннотация `werf.io/weight`) скорее всего не будут поддерживаться при применении манифестов сторонним инструментом.

Если требуется разделить первый и второй шаг, то это можно сделать так:

```shell
werf build --repo example.org/mycompany/myapp
```

```
werf render --skip-build --output manifests.yaml --repo example.org/mycompany/myapp
```

## Развертывание сторонним инструментом без доступа к Git-репозиторию приложения

Если нужно выполнить применение конечных манифестов приложения не с werf, а с использованием другого инструмента (kubectl, Helm, ...), при этом не имея доступа к Git-репозиторию приложения, то необходимо выполнить три шага:

1. Сборка образов и их публикация в container registry.

2. Публикация основного чарта и переданных ему параметров как *бандла* в OCI-репозиторий. Бандл содержит указатели на опубликованные в первом шаге образы.

3. Формирование из бандла конечных манифестов.

4. Развертывание получившихся манифестов в кластер используя сторонний инструмент.

Первые два шага выполняются командой `werf bundle publish`, находясь в Git-репозитории приложения:

```shell
werf bundle publish --tag latest --repo example.org/mycompany/myapp
```

А третий шаг выполняется командой `werf bundle render` уже без необходимости находиться в Git-репозитории приложения, например:

```shell
werf bundle render --output manifests.yaml --tag latest --release myapp --namespace myapp-production --repo example.org/mycompany/myapp
```

Теперь полученные манифесты можно передать в сторонний инструмент для дальнейшего развертывания, например:

```shell
kubectl apply -f manifests.yaml
```

> Обратите внимание, что некоторые специальные возможности werf вроде возможности изменения порядка развертывания ресурсов на основании их веса (аннотация `werf.io/weight`) скорее всего не будут поддерживаться при применении манифестов сторонним инструментом.

Если требуется разделить первый и второй шаг, то это можно сделать так:

```shell
werf build --repo example.org/mycompany/myapp
```

```
werf bundle publish --skip-build --tag latest --repo example.org/mycompany/myapp
```

## Удаление развернутого приложения

Удалить развернутое приложение можно командой `werf dismiss`, запущенной из Git-репозитория приложения, например:

```shell
werf dismiss --env staging
```
